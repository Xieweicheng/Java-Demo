查看源码时多多少少会接触到 `native` 这个关键字，例如 `Math.sqrt(double a)` 方法，底层使用的就是 `public static native double sqrt(double a)` 。那什么是 `native` 方法？

`Native Method` 其实就是一个 Java 调用非 Java 代码的接口。

`JNI` 是 `Java Native Interface` 的缩写，它提供了若干的 API 实现 Java 和 其他语言的通讯（主要是 C/C++）

那么，这个方法的实现是放在哪的呢？

这些方法的实现，实际上就是 C/C++ 的源码（后缀为`.c`和`.cpp`等），通过对源码进行预编译、编译、汇编和链接为 `.dll` （win下）或者 `.so` （Linux下）动态库，最后通过 Java 中的 `System.loadLibrary(String libname)` 方法加载到内存中。

下面介绍如何通过 Java 中 调用 C 的函数和 C 中调用 Java 中的函数（特意花了一下午学习 C 语言的语法）。

先创建一个叫 `JNI.java` 的文件，放在 `cn/mrxiexie/jni` 文件夹下，定义我们编译后的动态库名为 `JNI`，对应 win 下的 `JNI.dll` 和 Linux 下的 `libJNI.so` 文件。注意：Linux 下的动态库格式规定前缀为 `lib`，使用 `System.loadLibrary` 时，只需把前缀和后缀去掉的中间部分传入参即可。

```java
package cn.mrxiexie.jni;

import java.util.Arrays;
import java.util.Random;

public class JNI {

    static {
        try {
            // 此处即为本地方法所在链接库名
            System.loadLibrary("JNI");
        } catch (UnsatisfiedLinkError e) {
            System.err.println("Cannot load JNI library:\n " + e.toString());
        }
    }

    public static native double[] sqrt(int[] nums);

    public static native int max();

    public native int min();

    public static void log(String msg) {
        System.out.println("In C " + msg);
    }

    public static int[] getNums(int count) {
        int[] nums = new int[count];
        Random random = new Random();
        for (int i = 0; i < count; i++) {
            nums[i] = random.nextInt(count);
        }
        System.out.println("In Java getNums ： " + Arrays.toString(nums));
        return nums;
    }

    public static void main(String[] args) {
        JNI jni = new JNI();
        int max = max();
        System.out.println("In Java max num is " + max);
        int min = jni.min();
        System.out.println("In Java min num is " + min);
        int[] nums = JNI.getNums(10);
        double[] sqrt = sqrt(nums);
        System.out.println("In Java sqrt num is " + Arrays.toString(sqrt));
    }
}
```

使用 `javac cn/mrxiexie/jni/JNI.java` 编译或者 `JNI.class` 文件。

使用 `javah cn.mrxiexie.jni.JNI ` 获取 `cn_mrxiexie_jni_JNI.h` 头文件。

`.h` 文件包含了在 Java 端编写的 `Native` 方法声明 `JNIEXPORT jint JNICALL Java_cn_mrxiexie_jni_JNI_max
  (JNIEnv *, jclass);` 和各种 C/C++ 中的宏定义（`#`开头的），文件内容如下：

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class cn_mrxiexie_jni_JNI */

#ifndef _Included_cn_mrxiexie_jni_JNI
#define _Included_cn_mrxiexie_jni_JNI
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     cn_mrxiexie_jni_JNI
 * Method:    sqrt
 * Signature: ([I)[D
 */
JNIEXPORT jdoubleArray JNICALL Java_cn_mrxiexie_jni_JNI_sqrt
  (JNIEnv *, jclass, jintArray);

/*
 * Class:     cn_mrxiexie_jni_JNI
 * Method:    max
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_cn_mrxiexie_jni_JNI_max
  (JNIEnv *, jclass);

/*
 * Class:     cn_mrxiexie_jni_JNI
 * Method:    min
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_cn_mrxiexie_jni_JNI_min
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

单有方法声明可没什么用，现在我们把具体的方法实现放在 `JNI.c` 中，该方法主要实现从 Java 的 `getNums` 方法获取数值数组，再通过对数值数组进行遍历，求出数组中的最大值，并返回给 Java 中的 `max` 方法。

在看 `JNI.c` 文件内容前，先科普一下 `JNI` 的基础知识：

### JNI 基础知识

基础数据类型：

下表的 C、Java 和 JNI 的关系（以下关系可以查阅 JDK 下的 `jni.h` 和 `jni_mh.h` 文件，我的是Linux系统下的 `/usr/lib/jvm/java-8-jdk/include` ）：

```c
// /usr/lib/jvm/java-8-jdk/include/linux/jni_mh.h
typedef int jint;
#ifdef _LP64 /* 64-bit Solaris */
typedef long jlong;
#else
typedef long long jlong;
#endif
typedef signed char jbyte;
// /usr/lib/jvm/java-8-jdk/include/jni.h
typedef unsigned char   jboolean;
typedef unsigned short  jchar;
typedef short           jshort;
typedef float           jfloat;
typedef double          jdouble;
typedef jint            jsize;
```

| Java    | JNI      | C              |
| ------- | -------- | -------------- |
| int     | jint     | int            |
| long    | jlong    | long/long long |
| byte    | jbyte    | signed char    |
| boolean | jboolean | unsigned char  |
| char    | jchar    | unsigned short |
| short   | jshort   | short          |
| float   | jfloat   | float          |
| double  | jdouble  | double         |

引用类型：

`jni.h` 中定义了 `_jobject` 结构体，代表 Java 中的 `java.lang.Object`

```c
// /usr/lib/jvm/java-8-jdk/include/jni.h
struct _jobject;

typedef struct _jobject *jobject;
typedef jobject jclass;
typedef jobject jthrowable;
typedef jobject jstring;
typedef jobject jarray;
typedef jarray jbooleanArray;
typedef jarray jbyteArray;
typedef jarray jcharArray;
typedef jarray jshortArray;
typedef jarray jintArray;
typedef jarray jlongArray;
typedef jarray jfloatArray;
typedef jarray jdoubleArray;
typedef jarray jobjectArray;
```

| Java                | JNI        | C        |
| ------------------- | ---------- | -------- |
| java.lang.Object    | jobject    | _jobject |
| java.lang.Class     | jclass     | _jobject |
| java.lang.Throwable | jthrowable | _jobject |
| java.lang.String    | jstring    | _jobject |
| 数组                | jarray     | _jobject |

C/C++ 中定义的 Native 函数，入参和出餐都是上述的类型。

对于基础数据类型如：`jint`，`jlong`等，可以直接参与运行不需要任何转换。

对于引用类型如：`jstring`，`jintarray`等，需要转换为 `char*`，`int[]` 等，如何转换呢？所有的 Native 函数入参都有 `JNIENV *env`，静态 Native 函数额外有 `jclass thisClass`（max 方法），普通 Native 函数额外有 `jobject thisObj`（min 方法）：

- `JNIENV *env`：这是一个指向 JNI 运行环境的指针，我们可以通过该方法调用 JNI 函数，如将 jstring 转为 `char*` 等
- `jclass thisClass`：静态 Native 方法所在类
- `jobject thisObj`：普通 Native 方法所在类的对象

`JNI.c` 文件内容如下：

```c
// 导入同目录下的 `cn_mrxiexie_jni_JNI.h` 头文件
#include "cn_mrxiexie_jni_JNI.h"
// 导入系统中同名的头文件，可以理解为 Java 中的 import
#include <jni.h>
// 求平方根需要用到 `math.h` 中的 `double sqrt(double)` 方法
#include <math.h>
// 输入输出
#include <stdio.h>

jmethodID logMethodId;

void java_log(JNIEnv *env, jclass thisClass, char *msg) {
  if (NULL == logMethodId) {
    logMethodId = (*env)->GetStaticMethodID(env, thisClass, "log",
                                            "(Ljava/lang/String;)V");
  }
  jstring message = (*env)->NewStringUTF(env, msg);
  (*env)->CallStaticVoidMethod(env, thisClass, logMethodId, message);
}

/*
 * 把 nums 所有元素开根号后返回
 *
 * 入参 jintArray nums 为需要开平方的数组
 * 第一步先把 jintArray 通过 env 的方法转换为 jint[]（即 int[]）
 * 第二步通过 env 的方法获取 jintArray 的长度
 * 第三步循环 nums_intPointer（jint[]），并通过 `math.h` 的 sqrt
 * 开根号把结果放在 sqrtArray（double[]） 数组中 最后把通过 env 的方法把
 * double[] 转为 jdoubleArray 并返回
 *
 * Class:     cn_mrxiexie_jni_JNI
 * Method:    sqrt
 * Signature: ([I)[D
 */
JNIEXPORT jdoubleArray JNICALL Java_cn_mrxiexie_jni_JNI_sqrt(JNIEnv *env,
                                                             jclass thisClass,
                                                             jintArray nums) {
  java_log(env, thisClass, "sqrt");
  // 将 jintArray 转换为 jint[]
  jint *nums_intPointer = (*env)->GetIntArrayElements(env, nums, NULL);
  if (nums_intPointer == NULL) {
    return 0;
  }
  jsize nums_Len = (*env)->GetArrayLength(env, nums);
  double sqrtArray[nums_Len];
  for (int i = 0; i < nums_Len; i++) {
    sqrtArray[i] = sqrt((double)*(nums_intPointer + i));
  }
  jdoubleArray doublearray_Ret = (*env)->NewDoubleArray(
      env, nums_Len); // 将需要返回的数组长度len，作为入参
  (*env)->SetDoubleArrayRegion(env, doublearray_Ret, 0, nums_Len,
                               sqrtArray); // c_array 对应C代码的数组指针
  return doublearray_Ret;
}

/*
 * 求数组的最大值并返回，数组从 java 中的 getnums(count) 获取，count 为数组长度
 *
 * 第一步通过 env 的方法获取到 getNums 的 jmethodID（类似与 Java 中的反射）
 * 第二步通过 env 的方法调用 getNums 静态方法获取到数组 numbs(jintArray)
 * 第三步把 numbs(jintArray) 通过 env 的方法转换为 jint[]（即 int[]）
 * 第四步通过 env 的方法获取 jintArray 的长度
 * 最后循环 jintArray 数组并返回最大值
 *
 * Class:     cn_mrxiexie_jni_JNI
 * Method:    max
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_cn_mrxiexie_jni_JNI_max(JNIEnv *env,
                                                    jclass thisClass) {
  java_log(env, thisClass, "max");
  // 获取方法 id
  jmethodID getNums =
      (*env)->GetStaticMethodID(env, thisClass, "getNums", "(I)[I");
  if (NULL == getNums)
    return 0;
  // 调用 Java 中的静态方法
  jintArray numbs = (*env)->CallStaticObjectMethod(env, thisClass, getNums, 10);

  // 将 jintArray 转换为 jint[]
  jint *intArray = (*env)->GetIntArrayElements(env, numbs, NULL);
  jsize length = (*env)->GetArrayLength(env, numbs);
  jint max = *(intArray + 1);
  for (int i = 0; i < length; i++) {
    jint temp = *(intArray + i);
    if (max < temp) {
      max = temp;
    }
  }
  return max;
}

/*
 * 求数组的最小值并返回，数组从 java 中的 getnums(count) 获取，count 为数组长度
 *
 * 注意：流程跟求最大值基本一致，由于 min 为普通 native 方法，入参为
 * jobject，所以第一步需要通过 env 的方法从 thisObj(jobject) 中获取到
 * thisClass(jclass)
 *
 * Class:     cn_mrxiexie_jni_JNI
 * Method:    min
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_cn_mrxiexie_jni_JNI_min(JNIEnv *env,
                                                    jobject thisObj) {
  // 通过 thisObj 对象获取对象的类
  jclass thisClass = (*env)->GetObjectClass(env, thisObj);
  java_log(env, thisClass, "min");

  // 获取方法 id
  jmethodID getNums =
      (*env)->GetStaticMethodID(env, thisClass, "getNums", "(I)[I");
  if (NULL == getNums)
    return 0;
  // 调用 Java 中的静态方法
  jintArray numbs = (*env)->CallStaticObjectMethod(env, thisClass, getNums, 10);

  // 将 jintArray 转换为 jint[]
  jint *intArray = (*env)->GetIntArrayElements(env, numbs, NULL);
  jsize length = (*env)->GetArrayLength(env, numbs);
  jint min = *(intArray + 1);
  for (int i = 0; i < length; i++) {
    jint temp = *(intArray + i);
    if (min > temp) {
      min = temp;
    }
  }
  return min;
}
```

内容中都有注释，就不一一讲解了，需要注意的是，获取 `jmethodID` 的时候需要用到方法签名 `(Ljava/lang/String;)V`，什么是方法签名，可以查看这篇文章。[方法签名](https://mrxiexie.cn/Java%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D.html)

最后我们需要把 `JNI.c` 源码文件，编译链接为 `libJNI.so` 或者 `JNI.dll` 文件：

```shell
# 编译过程中需要用到 `jni.h`，`jni.h` 又引入了 `jni_md.h`，这两个文件分别在 jdk 的目录下，jdk/include 和 jdk/include/linux，编译后生成 `JNI.o` 目标文件。
gcc -I /lib64/jvm/java-8-jdk/include -I /lib64/jvm/java-8-jdk/include/linux -fPIC -c JNI.c -o JNI.o
# 生成动态库
gcc -shared -o libJNI.so JNI.o

# 以上两条命令可以结合为以下一条
gcc -fPIC --shared JNI.c -o libJNI.so -I /lib64/jvm/java-8-jdk/include -I /lib64/jvm/java-8-jdk/include/linux
```

好了，`libJNI.so` 动态库有了，`JNI.class` 也有了，可以直接运行了：

```shell
# java.library.path 指向非Java包的位置，如（.dll、.so）
java -Djava.library.path=. cn.mrxiexie.jni.JNI
```

执行结果如下：

```
In C max
In Java getNums ： [3, 5, 9, 8, 2, 9, 9, 2, 0, 7]
In Java max num is 9
In C min
In Java getNums ： [5, 4, 9, 6, 7, 0, 5, 8, 0, 8]
In Java min num is 0
In Java getNums ： [0, 8, 5, 0, 2, 9, 2, 9, 6, 2]
In C sqrt
In Java sqrt num is [0.0, 2.8284271247461903, 2.23606797749979, 0.0, 1.4142135623730951, 3.0, 1.4142135623730951, 3.0, 2.449489742783178, 1.4142135623730951]
```

下载本文所有代码：[传送门](/downloads/JNI.tar.gz)

官方文档：[传送门](https://docs.oracle.com/en/java/javase/12/docs/specs/jni/index.html)，其中 JNI 的方法可以在官方文档的 [Chapter 4: JNI Functions](https://docs.oracle.com/en/java/javase/12/docs/specs/jni/functions.html) 中查阅。